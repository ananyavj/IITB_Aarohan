import { db } from '@/db/db';
import type { AIOutput, AIRequest, AIFeedback, Chapter } from '@/db/db';
import { logSyncEvent } from './syncRepository';

const MOCK_DELAY = 1500; // Simulate network

// Mock AI Service until backend is ready
const generateMockResponse = (type: string, prompt: string): string => {
    // Dynamic Mock Data Generation
    if (type === 'summary') {
        const topic = prompt.replace('Summarize lesson', '').trim();
        return `## ${topic} Summary
Based on the content, here are the key takeaways for ${topic}...

*Generated by AI Assistant*`;
    }
    else if (type === 'mindmap') {
        const topic = prompt.toLowerCase();

        // Geometry Mock Data
        if (topic.includes('geometry') || topic.includes('shape') || topic.includes('lines')) {
            return JSON.stringify({
                nodes: [
                    { id: 'root', label: 'Geometry', type: 'root', level: 0 },
                    { id: '1', label: 'Shapes', type: 'branch', level: 1 },
                    { id: '2', label: 'Coordinates', type: 'branch', level: 1 },
                    { id: '1a', label: 'Triangles', type: 'leaf', level: 2 },
                    { id: '1b', label: 'Circles', type: 'leaf', level: 2 },
                    { id: '2a', label: 'X-Axis', type: 'leaf', level: 2 },
                    { id: '2b', label: 'Y-Axis', type: 'leaf', level: 2 }
                ],
                edges: [
                    { source: 'root', target: '1' },
                    { source: 'root', target: '2' },
                    { source: '1', target: '1a' },
                    { source: '1', target: '1b' },
                    { source: '2', target: '2a' },
                    { source: '2', target: '2b' }
                ]
            });
        }

        // Algebra Mock Data
        if (topic.includes('algebra') || topic.includes('equation') || topic.includes('polynomial')) {
            return JSON.stringify({
                nodes: [
                    { id: 'root', label: 'Algebra', type: 'root', level: 0 },
                    { id: '1', label: 'Variables', type: 'branch', level: 1 },
                    { id: '2', label: 'Equations', type: 'branch', level: 1 },
                    { id: '1a', label: 'Constants', type: 'leaf', level: 2 },
                    { id: '1b', label: 'Coefficients', type: 'leaf', level: 2 },
                    { id: '2a', label: 'Linear', type: 'leaf', level: 2 },
                    { id: '2b', label: 'Quadratic', type: 'leaf', level: 2 }
                ],
                edges: [
                    { source: 'root', target: '1' },
                    { source: 'root', target: '2' },
                    { source: '1', target: '1a' },
                    { source: '1', target: '1b' },
                    { source: '2', target: '2a' },
                    { source: '2', target: '2b' }
                ]
            });
        }

        // Default Data (Real Numbers)
        return JSON.stringify({
            nodes: [
                { id: 'root', label: 'Real Numbers', type: 'root', level: 0 },
                { id: '1', label: 'Rational', type: 'branch', level: 1 },
                { id: '2', label: 'Irrational', type: 'branch', level: 1 },
                { id: '1a', label: 'Integers', type: 'leaf', level: 2 },
                { id: '1b', label: 'Fractions', type: 'leaf', level: 2 },
                { id: '2a', label: 'Pi (π)', type: 'leaf', level: 2 },
                { id: '2b', label: 'Root 2', type: 'leaf', level: 2 }
            ],
            edges: [
                { source: 'root', target: '1' },
                { source: 'root', target: '2' },
                { source: '1', target: '1a' },
                { source: '1', target: '1b' },
                { source: '2', target: '2a' },
                { source: '2', target: '2b' }
            ]
        });
    }
    else if (type === 'factcheck') {
        return `**Fact Check Result**
Query: "${prompt}"

✅ **Verified**: The concept described fits the standard definition in NCERT textbooks.
*Confidence: 95%*`;
    }

    return `AI Response to: "${prompt}"`;
};

/**
 * Fetch or generate a lesson summary
 * Checks for existing cached output first
 */
export const fetchLessonSummary = async (lessonId: number, userId: number): Promise<AIOutput> => {
    // 1. Check if we already have a request/output for this context
    // Ideally we store contextId in AIRequest to link it back, but for now using a prompt convention or simple query
    const contextTag = `lesson_summary_${lessonId}`;

    // Find latest request for this lesson
    const existingRequest = await db.aiRequests
        .where('userId')
        .equals(userId)
        .filter(r => r.context === contextTag)
        .last();

    if (existingRequest) {
        // Find output for this request
        const output = await db.aiOutputs
            .where('requestId')
            .equals(existingRequest.id!)
            .first();

        if (output) return output;
    }

    // 2. If not found, simulate "Online" AI call
    // In real app: Queue request -> Sync -> Backend -> Sync -> UI

    // Create Request
    const requestId = await db.aiRequests.add({
        userId,
        prompt: `Summarize lesson ${lessonId}`,
        context: contextTag,
        createdAt: new Date()
    });

    // Simulate Processing
    await new Promise(resolve => setTimeout(resolve, MOCK_DELAY));

    // Create Output
    const content = generateMockResponse('summary', `Lesson ${lessonId}`);
    const outputId = await db.aiOutputs.add({
        requestId: requestId as number,
        content,
        createdAt: new Date()
    });

    return {
        id: outputId as number,
        requestId: requestId as number,
        content,
        createdAt: new Date()
    };
};

/**
 * Fetch or generate a mind map
 */
export const fetchMindMap = async (chapterId: number, userId: number): Promise<AIOutput> => {
    // V3 tag to force regeneration with dynamic data
    const contextTag = `mindmap_v3_chapter_${chapterId}`;

    const existingRequest = await db.aiRequests
        .where('userId')
        .equals(userId)
        .filter(r => r.context === contextTag)
        .last();

    if (existingRequest) {
        const output = await db.aiOutputs
            .where('requestId')
            .equals(existingRequest.id!)
            .first();
        if (output) return output;
    }

    // Fetch chapter title for deeper context
    const chapter = await db.chapters.get(chapterId);
    const chapterTitle = chapter ? chapter.title : `Chapter ${chapterId}`;

    const requestId = await db.aiRequests.add({
        userId,
        prompt: chapterTitle,
        context: contextTag,
        createdAt: new Date()
    });

    await new Promise(resolve => setTimeout(resolve, MOCK_DELAY));

    const content = generateMockResponse('mindmap', chapterTitle);
    const outputId = await db.aiOutputs.add({
        requestId: requestId as number,
        content,
        createdAt: new Date()
    });

    return { id: outputId as number, requestId: requestId as number, content, createdAt: new Date() };
};

export const submitFactCheck = async (query: string, userId: number): Promise<AIOutput> => {
    const requestId = await db.aiRequests.add({
        userId,
        prompt: query,
        context: 'tool_factcheck',
        createdAt: new Date()
    });

    await new Promise(resolve => setTimeout(resolve, MOCK_DELAY));

    const content = generateMockResponse('factcheck', query);
    const outputId = await db.aiOutputs.add({
        requestId: requestId as number,
        content,
        createdAt: new Date()
    });

    return { id: outputId as number, requestId: requestId as number, content, createdAt: new Date() };
};

/**
 * Submit feedback for an AI output
 */
export const submitFeedback = async (
    requestId: number,
    userId: number,
    rating: number,
    comment?: string
): Promise<number> => {
    // Check if feedback already exists
    const existing = await db.aiFeedback.where('requestId').equals(requestId).first();
    if (existing) {
        // Update
        await db.aiFeedback.update(existing.id!, { rating, comment });
        await logSyncEvent('ai_feedback', existing.id!, 'update');
        return existing.id!;
    }

    // Create
    const feedbackId = await db.aiFeedback.add({
        requestId,
        userId,
        rating,
        comment,
        createdAt: new Date()
    });
    await logSyncEvent('ai_feedback', feedbackId as number, 'create');
    return feedbackId as number;
};
